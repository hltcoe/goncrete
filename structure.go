// Autogenerated by Thrift Compiler (0.10.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package goncrete

import (
	"bytes"
	"database/sql/driver"
	"errors"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

//Enumerated types of Tokenizations
type TokenizationKind int64
const (
  TokenizationKind_TOKEN_LIST TokenizationKind = 1
  TokenizationKind_TOKEN_LATTICE TokenizationKind = 2
)

func (p TokenizationKind) String() string {
  switch p {
  case TokenizationKind_TOKEN_LIST: return "TOKEN_LIST"
  case TokenizationKind_TOKEN_LATTICE: return "TOKEN_LATTICE"
  }
  return "<UNSET>"
}

func TokenizationKindFromString(s string) (TokenizationKind, error) {
  switch s {
  case "TOKEN_LIST": return TokenizationKind_TOKEN_LIST, nil 
  case "TOKEN_LATTICE": return TokenizationKind_TOKEN_LATTICE, nil 
  }
  return TokenizationKind(0), fmt.Errorf("not a valid TokenizationKind string")
}


func TokenizationKindPtr(v TokenizationKind) *TokenizationKind { return &v }

func (p TokenizationKind) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TokenizationKind) UnmarshalText(text []byte) error {
q, err := TokenizationKindFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TokenizationKind) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TokenizationKind(v)
return nil
}

func (p * TokenizationKind) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// A single parse constituent (or "phrase").
// 
// Attributes:
//  - ID: A parse-relative identifier for this consistuent. Together
// with the UUID for a Parse, this can be used to define
// pointers to specific constituents.
//  - Tag: A description of this constituency node, e.g. the category "NP".
// For leaf nodes, this should be a word and for pre-terminal nodes
// this should be a POS tag.
//  - ChildList
//  - HeadChildIndex: The index of the head child of this constituent. I.e., the
// head child of constituent <tt>c</tt> is
// <tt>c.children[c.head_child_index]</tt>. A value of -1
// indicates that no child head was identified.
//  - Start: The first token (inclusive) of this constituent in the
// parent Tokenization. Almost certainly should be populated.
//  - Ending: The last token (exclusive) of this constituent in the
// parent Tokenization. Almost certainly should be populated.
type Constituent struct {
  ID int32 `thrift:"id,1,required" db:"id" json:"id"`
  Tag *string `thrift:"tag,2" db:"tag" json:"tag,omitempty"`
  ChildList []int32 `thrift:"childList,3,required" db:"childList" json:"childList"`
  HeadChildIndex int32 `thrift:"headChildIndex,4" db:"headChildIndex" json:"headChildIndex,omitempty"`
  Start *int32 `thrift:"start,5" db:"start" json:"start,omitempty"`
  Ending *int32 `thrift:"ending,6" db:"ending" json:"ending,omitempty"`
}

func NewConstituent() *Constituent {
  return &Constituent{
HeadChildIndex: -1,
}
}


func (p *Constituent) GetID() int32 {
  return p.ID
}
var Constituent_Tag_DEFAULT string
func (p *Constituent) GetTag() string {
  if !p.IsSetTag() {
    return Constituent_Tag_DEFAULT
  }
return *p.Tag
}

func (p *Constituent) GetChildList() []int32 {
  return p.ChildList
}
var Constituent_HeadChildIndex_DEFAULT int32 = -1

func (p *Constituent) GetHeadChildIndex() int32 {
  return p.HeadChildIndex
}
var Constituent_Start_DEFAULT int32
func (p *Constituent) GetStart() int32 {
  if !p.IsSetStart() {
    return Constituent_Start_DEFAULT
  }
return *p.Start
}
var Constituent_Ending_DEFAULT int32
func (p *Constituent) GetEnding() int32 {
  if !p.IsSetEnding() {
    return Constituent_Ending_DEFAULT
  }
return *p.Ending
}
func (p *Constituent) IsSetTag() bool {
  return p.Tag != nil
}

func (p *Constituent) IsSetHeadChildIndex() bool {
  return p.HeadChildIndex != Constituent_HeadChildIndex_DEFAULT
}

func (p *Constituent) IsSetStart() bool {
  return p.Start != nil
}

func (p *Constituent) IsSetEnding() bool {
  return p.Ending != nil
}

func (p *Constituent) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetID bool = false;
  var issetChildList bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetChildList = true
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
    case 6:
      if err := p.ReadField6(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
  }
  if !issetChildList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ChildList is not set"));
  }
  return nil
}

func (p *Constituent)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *Constituent)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Tag = &v
}
  return nil
}

func (p *Constituent)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.ChildList =  tSlice
  for i := 0; i < size; i ++ {
var _elem0 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem0 = v
}
    p.ChildList = append(p.ChildList, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Constituent)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.HeadChildIndex = v
}
  return nil
}

func (p *Constituent)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Start = &v
}
  return nil
}

func (p *Constituent)  ReadField6(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Ending = &v
}
  return nil
}

func (p *Constituent) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Constituent"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Constituent) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *Constituent) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetTag() {
    if err := oprot.WriteFieldBegin("tag", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tag: ", p), err) }
    if err := oprot.WriteString(string(*p.Tag)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.tag (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tag: ", p), err) }
  }
  return err
}

func (p *Constituent) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("childList", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:childList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.I32, len(p.ChildList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ChildList {
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:childList: ", p), err) }
  return err
}

func (p *Constituent) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetHeadChildIndex() {
    if err := oprot.WriteFieldBegin("headChildIndex", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:headChildIndex: ", p), err) }
    if err := oprot.WriteI32(int32(p.HeadChildIndex)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.headChildIndex (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:headChildIndex: ", p), err) }
  }
  return err
}

func (p *Constituent) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetStart() {
    if err := oprot.WriteFieldBegin("start", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:start: ", p), err) }
    if err := oprot.WriteI32(int32(*p.Start)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.start (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:start: ", p), err) }
  }
  return err
}

func (p *Constituent) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetEnding() {
    if err := oprot.WriteFieldBegin("ending", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:ending: ", p), err) }
    if err := oprot.WriteI32(int32(*p.Ending)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ending (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:ending: ", p), err) }
  }
  return err
}

func (p *Constituent) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Constituent(%+v)", *p)
}

// A theory about the syntactic parse of a sentence.
// 
// \note If we add support for parse forests in the future, then it
// will most likely be done by adding a new field (e.g.
// "<tt>forest_root</tt>") that uses a new struct type to encode the
// forest. A "<tt>kind</tt>" field might also be added (analogous to
// <tt>Tokenization.kind</tt>) to indicate whether a parse is encoded
// using a simple tree or a parse forest.
// 
// Attributes:
//  - UUID
//  - Metadata
//  - ConstituentList
type Parse struct {
  UUID *UUID `thrift:"uuid,1,required" db:"uuid" json:"uuid"`
  Metadata *AnnotationMetadata `thrift:"metadata,2,required" db:"metadata" json:"metadata"`
  ConstituentList []*Constituent `thrift:"constituentList,3,required" db:"constituentList" json:"constituentList"`
}

func NewParse() *Parse {
  return &Parse{}
}

var Parse_UUID_DEFAULT *UUID
func (p *Parse) GetUUID() *UUID {
  if !p.IsSetUUID() {
    return Parse_UUID_DEFAULT
  }
return p.UUID
}
var Parse_Metadata_DEFAULT *AnnotationMetadata
func (p *Parse) GetMetadata() *AnnotationMetadata {
  if !p.IsSetMetadata() {
    return Parse_Metadata_DEFAULT
  }
return p.Metadata
}

func (p *Parse) GetConstituentList() []*Constituent {
  return p.ConstituentList
}
func (p *Parse) IsSetUUID() bool {
  return p.UUID != nil
}

func (p *Parse) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *Parse) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUUID bool = false;
  var issetMetadata bool = false;
  var issetConstituentList bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetUUID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetMetadata = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetConstituentList = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UUID is not set"));
  }
  if !issetMetadata{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Metadata is not set"));
  }
  if !issetConstituentList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConstituentList is not set"));
  }
  return nil
}

func (p *Parse)  ReadField1(iprot thrift.TProtocol) error {
  p.UUID = &UUID{}
  if err := p.UUID.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UUID), err)
  }
  return nil
}

func (p *Parse)  ReadField2(iprot thrift.TProtocol) error {
  p.Metadata = &AnnotationMetadata{
  KBest: 1,
}
  if err := p.Metadata.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Metadata), err)
  }
  return nil
}

func (p *Parse)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Constituent, 0, size)
  p.ConstituentList =  tSlice
  for i := 0; i < size; i ++ {
    _elem1 := &Constituent{
    HeadChildIndex: -1,
}
    if err := _elem1.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem1), err)
    }
    p.ConstituentList = append(p.ConstituentList, _elem1)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Parse) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Parse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Parse) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("uuid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := p.UUID.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UUID), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *Parse) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("metadata", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:metadata: ", p), err) }
  if err := p.Metadata.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Metadata), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:metadata: ", p), err) }
  return err
}

func (p *Parse) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("constituentList", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:constituentList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ConstituentList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ConstituentList {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:constituentList: ", p), err) }
  return err
}

func (p *Parse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Parse(%+v)", *p)
}

// A reference to a Constituent within a Parse.
// 
// Attributes:
//  - ParseId: The UUID of the Parse that this Constituent belongs to.
//  - ConstituentIndex: The index in the constituent list of this Constituent.
type ConstituentRef struct {
  ParseId *UUID `thrift:"parseId,1,required" db:"parseId" json:"parseId"`
  ConstituentIndex int32 `thrift:"constituentIndex,2,required" db:"constituentIndex" json:"constituentIndex"`
}

func NewConstituentRef() *ConstituentRef {
  return &ConstituentRef{}
}

var ConstituentRef_ParseId_DEFAULT *UUID
func (p *ConstituentRef) GetParseId() *UUID {
  if !p.IsSetParseId() {
    return ConstituentRef_ParseId_DEFAULT
  }
return p.ParseId
}

func (p *ConstituentRef) GetConstituentIndex() int32 {
  return p.ConstituentIndex
}
func (p *ConstituentRef) IsSetParseId() bool {
  return p.ParseId != nil
}

func (p *ConstituentRef) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetParseId bool = false;
  var issetConstituentIndex bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetParseId = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetConstituentIndex = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetParseId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ParseId is not set"));
  }
  if !issetConstituentIndex{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConstituentIndex is not set"));
  }
  return nil
}

func (p *ConstituentRef)  ReadField1(iprot thrift.TProtocol) error {
  p.ParseId = &UUID{}
  if err := p.ParseId.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ParseId), err)
  }
  return nil
}

func (p *ConstituentRef)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ConstituentIndex = v
}
  return nil
}

func (p *ConstituentRef) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("ConstituentRef"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ConstituentRef) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("parseId", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:parseId: ", p), err) }
  if err := p.ParseId.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ParseId), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:parseId: ", p), err) }
  return err
}

func (p *ConstituentRef) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("constituentIndex", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:constituentIndex: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConstituentIndex)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.constituentIndex (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:constituentIndex: ", p), err) }
  return err
}

func (p *ConstituentRef) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ConstituentRef(%+v)", *p)
}

// A syntactic edge between two tokens in a tokenized sentence.
// 
// Attributes:
//  - Gov: The governor or the head token. 0 indexed.
//  - Dep: The dependent token. 0 indexed.
//  - EdgeType: The relation that holds between gov and dep.
type Dependency struct {
  Gov int32 `thrift:"gov,1" db:"gov" json:"gov,omitempty"`
  Dep int32 `thrift:"dep,2,required" db:"dep" json:"dep"`
  EdgeType *string `thrift:"edgeType,3" db:"edgeType" json:"edgeType,omitempty"`
}

func NewDependency() *Dependency {
  return &Dependency{
Gov: -1,
}
}

var Dependency_Gov_DEFAULT int32 = -1

func (p *Dependency) GetGov() int32 {
  return p.Gov
}

func (p *Dependency) GetDep() int32 {
  return p.Dep
}
var Dependency_EdgeType_DEFAULT string
func (p *Dependency) GetEdgeType() string {
  if !p.IsSetEdgeType() {
    return Dependency_EdgeType_DEFAULT
  }
return *p.EdgeType
}
func (p *Dependency) IsSetGov() bool {
  return p.Gov != Dependency_Gov_DEFAULT
}

func (p *Dependency) IsSetEdgeType() bool {
  return p.EdgeType != nil
}

func (p *Dependency) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetDep bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetDep = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetDep{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Dep is not set"));
  }
  return nil
}

func (p *Dependency)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Gov = v
}
  return nil
}

func (p *Dependency)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Dep = v
}
  return nil
}

func (p *Dependency)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.EdgeType = &v
}
  return nil
}

func (p *Dependency) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Dependency"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Dependency) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetGov() {
    if err := oprot.WriteFieldBegin("gov", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:gov: ", p), err) }
    if err := oprot.WriteI32(int32(p.Gov)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.gov (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:gov: ", p), err) }
  }
  return err
}

func (p *Dependency) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("dep", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:dep: ", p), err) }
  if err := oprot.WriteI32(int32(p.Dep)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dep (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:dep: ", p), err) }
  return err
}

func (p *Dependency) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetEdgeType() {
    if err := oprot.WriteFieldBegin("edgeType", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:edgeType: ", p), err) }
    if err := oprot.WriteString(string(*p.EdgeType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.edgeType (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:edgeType: ", p), err) }
  }
  return err
}

func (p *Dependency) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Dependency(%+v)", *p)
}

// Information about the structure of a dependency parse.
// This information is computable from the list of dependencies,
// but this allows the consumer to make (verified) assumptions
// about the dependencies being processed.
// 
// Attributes:
//  - IsAcyclic: True iff there are no cycles in the dependency graph.
//  - IsConnected: True iff the dependency graph forms a single connected component.
//  - IsSingleHeaded: True iff every node in the dependency parse has at most
// one head/parent/governor.
//  - IsProjective: True iff there are no crossing edges in the dependency parse.
type DependencyParseStructure struct {
  IsAcyclic bool `thrift:"isAcyclic,1,required" db:"isAcyclic" json:"isAcyclic"`
  IsConnected bool `thrift:"isConnected,2,required" db:"isConnected" json:"isConnected"`
  IsSingleHeaded bool `thrift:"isSingleHeaded,3,required" db:"isSingleHeaded" json:"isSingleHeaded"`
  IsProjective bool `thrift:"isProjective,4,required" db:"isProjective" json:"isProjective"`
}

func NewDependencyParseStructure() *DependencyParseStructure {
  return &DependencyParseStructure{}
}


func (p *DependencyParseStructure) GetIsAcyclic() bool {
  return p.IsAcyclic
}

func (p *DependencyParseStructure) GetIsConnected() bool {
  return p.IsConnected
}

func (p *DependencyParseStructure) GetIsSingleHeaded() bool {
  return p.IsSingleHeaded
}

func (p *DependencyParseStructure) GetIsProjective() bool {
  return p.IsProjective
}
func (p *DependencyParseStructure) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetIsAcyclic bool = false;
  var issetIsConnected bool = false;
  var issetIsSingleHeaded bool = false;
  var issetIsProjective bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetIsAcyclic = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetIsConnected = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetIsSingleHeaded = true
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
      issetIsProjective = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetIsAcyclic{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IsAcyclic is not set"));
  }
  if !issetIsConnected{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IsConnected is not set"));
  }
  if !issetIsSingleHeaded{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IsSingleHeaded is not set"));
  }
  if !issetIsProjective{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IsProjective is not set"));
  }
  return nil
}

func (p *DependencyParseStructure)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.IsAcyclic = v
}
  return nil
}

func (p *DependencyParseStructure)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IsConnected = v
}
  return nil
}

func (p *DependencyParseStructure)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.IsSingleHeaded = v
}
  return nil
}

func (p *DependencyParseStructure)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.IsProjective = v
}
  return nil
}

func (p *DependencyParseStructure) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("DependencyParseStructure"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DependencyParseStructure) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("isAcyclic", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:isAcyclic: ", p), err) }
  if err := oprot.WriteBool(bool(p.IsAcyclic)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.isAcyclic (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:isAcyclic: ", p), err) }
  return err
}

func (p *DependencyParseStructure) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("isConnected", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:isConnected: ", p), err) }
  if err := oprot.WriteBool(bool(p.IsConnected)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.isConnected (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:isConnected: ", p), err) }
  return err
}

func (p *DependencyParseStructure) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("isSingleHeaded", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:isSingleHeaded: ", p), err) }
  if err := oprot.WriteBool(bool(p.IsSingleHeaded)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.isSingleHeaded (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:isSingleHeaded: ", p), err) }
  return err
}

func (p *DependencyParseStructure) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("isProjective", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:isProjective: ", p), err) }
  if err := oprot.WriteBool(bool(p.IsProjective)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.isProjective (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:isProjective: ", p), err) }
  return err
}

func (p *DependencyParseStructure) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DependencyParseStructure(%+v)", *p)
}

// Represents a dependency parse with typed edges.
// 
// Attributes:
//  - UUID
//  - Metadata
//  - DependencyList
//  - StructureInformation
type DependencyParse struct {
  UUID *UUID `thrift:"uuid,1,required" db:"uuid" json:"uuid"`
  Metadata *AnnotationMetadata `thrift:"metadata,2,required" db:"metadata" json:"metadata"`
  DependencyList []*Dependency `thrift:"dependencyList,3,required" db:"dependencyList" json:"dependencyList"`
  StructureInformation *DependencyParseStructure `thrift:"structureInformation,4" db:"structureInformation" json:"structureInformation,omitempty"`
}

func NewDependencyParse() *DependencyParse {
  return &DependencyParse{}
}

var DependencyParse_UUID_DEFAULT *UUID
func (p *DependencyParse) GetUUID() *UUID {
  if !p.IsSetUUID() {
    return DependencyParse_UUID_DEFAULT
  }
return p.UUID
}
var DependencyParse_Metadata_DEFAULT *AnnotationMetadata
func (p *DependencyParse) GetMetadata() *AnnotationMetadata {
  if !p.IsSetMetadata() {
    return DependencyParse_Metadata_DEFAULT
  }
return p.Metadata
}

func (p *DependencyParse) GetDependencyList() []*Dependency {
  return p.DependencyList
}
var DependencyParse_StructureInformation_DEFAULT *DependencyParseStructure
func (p *DependencyParse) GetStructureInformation() *DependencyParseStructure {
  if !p.IsSetStructureInformation() {
    return DependencyParse_StructureInformation_DEFAULT
  }
return p.StructureInformation
}
func (p *DependencyParse) IsSetUUID() bool {
  return p.UUID != nil
}

func (p *DependencyParse) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *DependencyParse) IsSetStructureInformation() bool {
  return p.StructureInformation != nil
}

func (p *DependencyParse) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUUID bool = false;
  var issetMetadata bool = false;
  var issetDependencyList bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetUUID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetMetadata = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetDependencyList = true
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UUID is not set"));
  }
  if !issetMetadata{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Metadata is not set"));
  }
  if !issetDependencyList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DependencyList is not set"));
  }
  return nil
}

func (p *DependencyParse)  ReadField1(iprot thrift.TProtocol) error {
  p.UUID = &UUID{}
  if err := p.UUID.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UUID), err)
  }
  return nil
}

func (p *DependencyParse)  ReadField2(iprot thrift.TProtocol) error {
  p.Metadata = &AnnotationMetadata{
  KBest: 1,
}
  if err := p.Metadata.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Metadata), err)
  }
  return nil
}

func (p *DependencyParse)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Dependency, 0, size)
  p.DependencyList =  tSlice
  for i := 0; i < size; i ++ {
    _elem2 := &Dependency{
    Gov: -1,
}
    if err := _elem2.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
    }
    p.DependencyList = append(p.DependencyList, _elem2)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *DependencyParse)  ReadField4(iprot thrift.TProtocol) error {
  p.StructureInformation = &DependencyParseStructure{}
  if err := p.StructureInformation.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.StructureInformation), err)
  }
  return nil
}

func (p *DependencyParse) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("DependencyParse"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DependencyParse) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("uuid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := p.UUID.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UUID), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *DependencyParse) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("metadata", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:metadata: ", p), err) }
  if err := p.Metadata.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Metadata), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:metadata: ", p), err) }
  return err
}

func (p *DependencyParse) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("dependencyList", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:dependencyList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.DependencyList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.DependencyList {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:dependencyList: ", p), err) }
  return err
}

func (p *DependencyParse) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetStructureInformation() {
    if err := oprot.WriteFieldBegin("structureInformation", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:structureInformation: ", p), err) }
    if err := p.StructureInformation.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.StructureInformation), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:structureInformation: ", p), err) }
  }
  return err
}

func (p *DependencyParse) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DependencyParse(%+v)", *p)
}

// A single token (typically a word) in a communication. The exact
// definition of what counts as a token is left up to the tools that
// generate token sequences.
// 
// Usually, each token will include at least a text string.
// 
// Attributes:
//  - TokenIndex: A 0-based tokenization-relative identifier for this token that
// represents the order that this token appears in the
// sentence. Together with the UUID for a Tokenization, this can be
// used to define pointers to specific tokens. If a Tokenization
// object contains multiple Token objects with the same id (e.g., in
// different n-best lists), then all of their other fields *must* be
// identical as well.
//  - Text: The text associated with this token.
// Note - we may have a destructive tokenizer (e.g., Stanford rewriting)
// and as a result, we want to maintain this field.
//  - TextSpan: Location of this token in this perspective's text (.text field).
// In cases where this token does not correspond directly with any
// text span in the text (such as word insertion during MT),
// this field may be given a value indicating "approximately" where
// the token comes from. A span covering the entire sentence may be
// used if no more precise value seems appropriate.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the document, but is the annotation's best
// effort at such a representation.
//  - RawTextSpan: Location of this token in the original, raw text (.originalText
// field).  In cases where this token does not correspond directly
// with any text span in the original text (such as word insertion
// during MT), this field may be given a value indicating
// "approximately" where the token comes from. A span covering the
// entire sentence may be used if no more precise value seems
// appropriate.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original raw document, but is the annotation's best
// effort at such a representation.
//  - AudioSpan: Location of this token in the original audio.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
type Token struct {
  TokenIndex int32 `thrift:"tokenIndex,1,required" db:"tokenIndex" json:"tokenIndex"`
  Text *string `thrift:"text,2" db:"text" json:"text,omitempty"`
  TextSpan *TextSpan `thrift:"textSpan,3" db:"textSpan" json:"textSpan,omitempty"`
  RawTextSpan *TextSpan `thrift:"rawTextSpan,4" db:"rawTextSpan" json:"rawTextSpan,omitempty"`
  AudioSpan *AudioSpan `thrift:"audioSpan,5" db:"audioSpan" json:"audioSpan,omitempty"`
}

func NewToken() *Token {
  return &Token{}
}


func (p *Token) GetTokenIndex() int32 {
  return p.TokenIndex
}
var Token_Text_DEFAULT string
func (p *Token) GetText() string {
  if !p.IsSetText() {
    return Token_Text_DEFAULT
  }
return *p.Text
}
var Token_TextSpan_DEFAULT *TextSpan
func (p *Token) GetTextSpan() *TextSpan {
  if !p.IsSetTextSpan() {
    return Token_TextSpan_DEFAULT
  }
return p.TextSpan
}
var Token_RawTextSpan_DEFAULT *TextSpan
func (p *Token) GetRawTextSpan() *TextSpan {
  if !p.IsSetRawTextSpan() {
    return Token_RawTextSpan_DEFAULT
  }
return p.RawTextSpan
}
var Token_AudioSpan_DEFAULT *AudioSpan
func (p *Token) GetAudioSpan() *AudioSpan {
  if !p.IsSetAudioSpan() {
    return Token_AudioSpan_DEFAULT
  }
return p.AudioSpan
}
func (p *Token) IsSetText() bool {
  return p.Text != nil
}

func (p *Token) IsSetTextSpan() bool {
  return p.TextSpan != nil
}

func (p *Token) IsSetRawTextSpan() bool {
  return p.RawTextSpan != nil
}

func (p *Token) IsSetAudioSpan() bool {
  return p.AudioSpan != nil
}

func (p *Token) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTokenIndex bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetTokenIndex = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTokenIndex{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TokenIndex is not set"));
  }
  return nil
}

func (p *Token)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TokenIndex = v
}
  return nil
}

func (p *Token)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Text = &v
}
  return nil
}

func (p *Token)  ReadField3(iprot thrift.TProtocol) error {
  p.TextSpan = &TextSpan{}
  if err := p.TextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TextSpan), err)
  }
  return nil
}

func (p *Token)  ReadField4(iprot thrift.TProtocol) error {
  p.RawTextSpan = &TextSpan{}
  if err := p.RawTextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RawTextSpan), err)
  }
  return nil
}

func (p *Token)  ReadField5(iprot thrift.TProtocol) error {
  p.AudioSpan = &AudioSpan{}
  if err := p.AudioSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AudioSpan), err)
  }
  return nil
}

func (p *Token) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Token"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Token) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tokenIndex", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tokenIndex: ", p), err) }
  if err := oprot.WriteI32(int32(p.TokenIndex)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tokenIndex (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tokenIndex: ", p), err) }
  return err
}

func (p *Token) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetText() {
    if err := oprot.WriteFieldBegin("text", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:text: ", p), err) }
    if err := oprot.WriteString(string(*p.Text)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.text (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:text: ", p), err) }
  }
  return err
}

func (p *Token) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTextSpan() {
    if err := oprot.WriteFieldBegin("textSpan", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:textSpan: ", p), err) }
    if err := p.TextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:textSpan: ", p), err) }
  }
  return err
}

func (p *Token) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetRawTextSpan() {
    if err := oprot.WriteFieldBegin("rawTextSpan", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rawTextSpan: ", p), err) }
    if err := p.RawTextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RawTextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rawTextSpan: ", p), err) }
  }
  return err
}

func (p *Token) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetAudioSpan() {
    if err := oprot.WriteFieldBegin("audioSpan", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:audioSpan: ", p), err) }
    if err := p.AudioSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AudioSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:audioSpan: ", p), err) }
  }
  return err
}

func (p *Token) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Token(%+v)", *p)
}

// A list of pointers to tokens that all belong to the same
// tokenization.
// 
// Attributes:
//  - TokenIndexList: The tokenization-relative identifiers for each token that is
// included in this sequence.
//  - AnchorTokenIndex: An optional field that can be used to describe
// the root of a sentence (if this sequence is a full sentence),
// the head of a constituent (if this sequence is a constituent),
// or some other form of "canonical" token in this sequence if,
// for instance, it is not easy to map this sequence to a another
// annotation that has a head.
// 
// This field is defined with respect to the Tokenization given
// by tokenizationId, and not to this object's tokenIndexList.
//  - TokenizationId: The UUID of the tokenization that contains the tokens.
//  - TextSpan: The text span in the main text (.text field) associated with this
// TokenRefSequence.
// 
// NOTE: This span represents a best guess, or 'provenance': it
// cannot be guaranteed that this text span matches the _exact_ text
// of the original document, but is the annotation's best effort at
// such a representation.
//  - RawTextSpan: The text span in the original text (.originalText field)
// associated with this TokenRefSequence.
// 
// NOTE: This span represents a best guess, or 'provenance': it
// cannot be guaranteed that this text span matches the _exact_ text
// of the original raw document, but is the annotation's best effort
// at such a representation.
//  - AudioSpan: The audio span associated with this TokenRefSequence.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
//  - Dependencies: Use this field to reference a dependency tree fragment
// such as a shortest path or all the dependents in a constituent.
//  - Constituent: Use this field to specify an entire constituent in a parse tree.
// Prefer textSpan over this field unless a node in a tree is needed.
type TokenRefSequence struct {
  TokenIndexList []int32 `thrift:"tokenIndexList,1,required" db:"tokenIndexList" json:"tokenIndexList"`
  AnchorTokenIndex int32 `thrift:"anchorTokenIndex,2" db:"anchorTokenIndex" json:"anchorTokenIndex,omitempty"`
  TokenizationId *UUID `thrift:"tokenizationId,3,required" db:"tokenizationId" json:"tokenizationId"`
  TextSpan *TextSpan `thrift:"textSpan,4" db:"textSpan" json:"textSpan,omitempty"`
  RawTextSpan *TextSpan `thrift:"rawTextSpan,5" db:"rawTextSpan" json:"rawTextSpan,omitempty"`
  AudioSpan *AudioSpan `thrift:"audioSpan,6" db:"audioSpan" json:"audioSpan,omitempty"`
  Dependencies []*Dependency `thrift:"dependencies,7" db:"dependencies" json:"dependencies,omitempty"`
  Constituent *ConstituentRef `thrift:"constituent,8" db:"constituent" json:"constituent,omitempty"`
}

func NewTokenRefSequence() *TokenRefSequence {
  return &TokenRefSequence{
AnchorTokenIndex: -1,
}
}


func (p *TokenRefSequence) GetTokenIndexList() []int32 {
  return p.TokenIndexList
}
var TokenRefSequence_AnchorTokenIndex_DEFAULT int32 = -1

func (p *TokenRefSequence) GetAnchorTokenIndex() int32 {
  return p.AnchorTokenIndex
}
var TokenRefSequence_TokenizationId_DEFAULT *UUID
func (p *TokenRefSequence) GetTokenizationId() *UUID {
  if !p.IsSetTokenizationId() {
    return TokenRefSequence_TokenizationId_DEFAULT
  }
return p.TokenizationId
}
var TokenRefSequence_TextSpan_DEFAULT *TextSpan
func (p *TokenRefSequence) GetTextSpan() *TextSpan {
  if !p.IsSetTextSpan() {
    return TokenRefSequence_TextSpan_DEFAULT
  }
return p.TextSpan
}
var TokenRefSequence_RawTextSpan_DEFAULT *TextSpan
func (p *TokenRefSequence) GetRawTextSpan() *TextSpan {
  if !p.IsSetRawTextSpan() {
    return TokenRefSequence_RawTextSpan_DEFAULT
  }
return p.RawTextSpan
}
var TokenRefSequence_AudioSpan_DEFAULT *AudioSpan
func (p *TokenRefSequence) GetAudioSpan() *AudioSpan {
  if !p.IsSetAudioSpan() {
    return TokenRefSequence_AudioSpan_DEFAULT
  }
return p.AudioSpan
}
var TokenRefSequence_Dependencies_DEFAULT []*Dependency

func (p *TokenRefSequence) GetDependencies() []*Dependency {
  return p.Dependencies
}
var TokenRefSequence_Constituent_DEFAULT *ConstituentRef
func (p *TokenRefSequence) GetConstituent() *ConstituentRef {
  if !p.IsSetConstituent() {
    return TokenRefSequence_Constituent_DEFAULT
  }
return p.Constituent
}
func (p *TokenRefSequence) IsSetAnchorTokenIndex() bool {
  return p.AnchorTokenIndex != TokenRefSequence_AnchorTokenIndex_DEFAULT
}

func (p *TokenRefSequence) IsSetTokenizationId() bool {
  return p.TokenizationId != nil
}

func (p *TokenRefSequence) IsSetTextSpan() bool {
  return p.TextSpan != nil
}

func (p *TokenRefSequence) IsSetRawTextSpan() bool {
  return p.RawTextSpan != nil
}

func (p *TokenRefSequence) IsSetAudioSpan() bool {
  return p.AudioSpan != nil
}

func (p *TokenRefSequence) IsSetDependencies() bool {
  return p.Dependencies != nil
}

func (p *TokenRefSequence) IsSetConstituent() bool {
  return p.Constituent != nil
}

func (p *TokenRefSequence) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTokenIndexList bool = false;
  var issetTokenizationId bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetTokenIndexList = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetTokenizationId = true
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
    case 6:
      if err := p.ReadField6(iprot); err != nil {
        return err
      }
    case 7:
      if err := p.ReadField7(iprot); err != nil {
        return err
      }
    case 8:
      if err := p.ReadField8(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTokenIndexList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TokenIndexList is not set"));
  }
  if !issetTokenizationId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TokenizationId is not set"));
  }
  return nil
}

func (p *TokenRefSequence)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.TokenIndexList =  tSlice
  for i := 0; i < size; i ++ {
var _elem3 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem3 = v
}
    p.TokenIndexList = append(p.TokenIndexList, _elem3)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenRefSequence)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.AnchorTokenIndex = v
}
  return nil
}

func (p *TokenRefSequence)  ReadField3(iprot thrift.TProtocol) error {
  p.TokenizationId = &UUID{}
  if err := p.TokenizationId.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TokenizationId), err)
  }
  return nil
}

func (p *TokenRefSequence)  ReadField4(iprot thrift.TProtocol) error {
  p.TextSpan = &TextSpan{}
  if err := p.TextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TextSpan), err)
  }
  return nil
}

func (p *TokenRefSequence)  ReadField5(iprot thrift.TProtocol) error {
  p.RawTextSpan = &TextSpan{}
  if err := p.RawTextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RawTextSpan), err)
  }
  return nil
}

func (p *TokenRefSequence)  ReadField6(iprot thrift.TProtocol) error {
  p.AudioSpan = &AudioSpan{}
  if err := p.AudioSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AudioSpan), err)
  }
  return nil
}

func (p *TokenRefSequence)  ReadField7(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Dependency, 0, size)
  p.Dependencies =  tSlice
  for i := 0; i < size; i ++ {
    _elem4 := &Dependency{
    Gov: -1,
}
    if err := _elem4.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
    }
    p.Dependencies = append(p.Dependencies, _elem4)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenRefSequence)  ReadField8(iprot thrift.TProtocol) error {
  p.Constituent = &ConstituentRef{}
  if err := p.Constituent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Constituent), err)
  }
  return nil
}

func (p *TokenRefSequence) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TokenRefSequence"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
    if err := p.writeField7(oprot); err != nil { return err }
    if err := p.writeField8(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TokenRefSequence) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tokenIndexList", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tokenIndexList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.I32, len(p.TokenIndexList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.TokenIndexList {
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tokenIndexList: ", p), err) }
  return err
}

func (p *TokenRefSequence) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetAnchorTokenIndex() {
    if err := oprot.WriteFieldBegin("anchorTokenIndex", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:anchorTokenIndex: ", p), err) }
    if err := oprot.WriteI32(int32(p.AnchorTokenIndex)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.anchorTokenIndex (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:anchorTokenIndex: ", p), err) }
  }
  return err
}

func (p *TokenRefSequence) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tokenizationId", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:tokenizationId: ", p), err) }
  if err := p.TokenizationId.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TokenizationId), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:tokenizationId: ", p), err) }
  return err
}

func (p *TokenRefSequence) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetTextSpan() {
    if err := oprot.WriteFieldBegin("textSpan", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:textSpan: ", p), err) }
    if err := p.TextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:textSpan: ", p), err) }
  }
  return err
}

func (p *TokenRefSequence) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetRawTextSpan() {
    if err := oprot.WriteFieldBegin("rawTextSpan", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:rawTextSpan: ", p), err) }
    if err := p.RawTextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RawTextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:rawTextSpan: ", p), err) }
  }
  return err
}

func (p *TokenRefSequence) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetAudioSpan() {
    if err := oprot.WriteFieldBegin("audioSpan", thrift.STRUCT, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:audioSpan: ", p), err) }
    if err := p.AudioSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AudioSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:audioSpan: ", p), err) }
  }
  return err
}

func (p *TokenRefSequence) writeField7(oprot thrift.TProtocol) (err error) {
  if p.IsSetDependencies() {
    if err := oprot.WriteFieldBegin("dependencies", thrift.LIST, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:dependencies: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Dependencies)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Dependencies {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:dependencies: ", p), err) }
  }
  return err
}

func (p *TokenRefSequence) writeField8(oprot thrift.TProtocol) (err error) {
  if p.IsSetConstituent() {
    if err := oprot.WriteFieldBegin("constituent", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:constituent: ", p), err) }
    if err := p.Constituent.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Constituent), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:constituent: ", p), err) }
  }
  return err
}

func (p *TokenRefSequence) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TokenRefSequence(%+v)", *p)
}

// Attributes:
//  - TokenIndex: A pointer to the token being tagged.
// 
// Token indices are 0-based. These indices are also 0-based.
//  - Tag: A string containing the annotation.
// If the tag set you are using is not case sensitive,
// then all part of speech tags should be normalized to upper case.
//  - Confidence: Confidence of the annotation.
//  - TagList: A list of strings that represent a distribution of possible
// tags for this token.
// 
// If populated, the 'tag' field should also be populated
// with the "best" value from this list.
//  - ConfidenceList: A list of doubles that represent confidences associated with
// the tags in the 'tagList' field.
// 
// If populated, the 'confidence' field should also be populated
// with the confidence associated with the "best" tag in 'tagList'.
type TaggedToken struct {
  TokenIndex *int32 `thrift:"tokenIndex,1" db:"tokenIndex" json:"tokenIndex,omitempty"`
  Tag *string `thrift:"tag,2" db:"tag" json:"tag,omitempty"`
  Confidence *float64 `thrift:"confidence,3" db:"confidence" json:"confidence,omitempty"`
  TagList []string `thrift:"tagList,4" db:"tagList" json:"tagList,omitempty"`
  ConfidenceList []float64 `thrift:"confidenceList,5" db:"confidenceList" json:"confidenceList,omitempty"`
}

func NewTaggedToken() *TaggedToken {
  return &TaggedToken{}
}

var TaggedToken_TokenIndex_DEFAULT int32
func (p *TaggedToken) GetTokenIndex() int32 {
  if !p.IsSetTokenIndex() {
    return TaggedToken_TokenIndex_DEFAULT
  }
return *p.TokenIndex
}
var TaggedToken_Tag_DEFAULT string
func (p *TaggedToken) GetTag() string {
  if !p.IsSetTag() {
    return TaggedToken_Tag_DEFAULT
  }
return *p.Tag
}
var TaggedToken_Confidence_DEFAULT float64
func (p *TaggedToken) GetConfidence() float64 {
  if !p.IsSetConfidence() {
    return TaggedToken_Confidence_DEFAULT
  }
return *p.Confidence
}
var TaggedToken_TagList_DEFAULT []string

func (p *TaggedToken) GetTagList() []string {
  return p.TagList
}
var TaggedToken_ConfidenceList_DEFAULT []float64

func (p *TaggedToken) GetConfidenceList() []float64 {
  return p.ConfidenceList
}
func (p *TaggedToken) IsSetTokenIndex() bool {
  return p.TokenIndex != nil
}

func (p *TaggedToken) IsSetTag() bool {
  return p.Tag != nil
}

func (p *TaggedToken) IsSetConfidence() bool {
  return p.Confidence != nil
}

func (p *TaggedToken) IsSetTagList() bool {
  return p.TagList != nil
}

func (p *TaggedToken) IsSetConfidenceList() bool {
  return p.ConfidenceList != nil
}

func (p *TaggedToken) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TaggedToken)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TokenIndex = &v
}
  return nil
}

func (p *TaggedToken)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Tag = &v
}
  return nil
}

func (p *TaggedToken)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Confidence = &v
}
  return nil
}

func (p *TaggedToken)  ReadField4(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.TagList =  tSlice
  for i := 0; i < size; i ++ {
var _elem5 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem5 = v
}
    p.TagList = append(p.TagList, _elem5)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TaggedToken)  ReadField5(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]float64, 0, size)
  p.ConfidenceList =  tSlice
  for i := 0; i < size; i ++ {
var _elem6 float64
    if v, err := iprot.ReadDouble(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem6 = v
}
    p.ConfidenceList = append(p.ConfidenceList, _elem6)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TaggedToken) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TaggedToken"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TaggedToken) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetTokenIndex() {
    if err := oprot.WriteFieldBegin("tokenIndex", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tokenIndex: ", p), err) }
    if err := oprot.WriteI32(int32(*p.TokenIndex)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.tokenIndex (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tokenIndex: ", p), err) }
  }
  return err
}

func (p *TaggedToken) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetTag() {
    if err := oprot.WriteFieldBegin("tag", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tag: ", p), err) }
    if err := oprot.WriteString(string(*p.Tag)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.tag (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tag: ", p), err) }
  }
  return err
}

func (p *TaggedToken) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetConfidence() {
    if err := oprot.WriteFieldBegin("confidence", thrift.DOUBLE, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:confidence: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.Confidence)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.confidence (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:confidence: ", p), err) }
  }
  return err
}

func (p *TaggedToken) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetTagList() {
    if err := oprot.WriteFieldBegin("tagList", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:tagList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRING, len(p.TagList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.TagList {
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:tagList: ", p), err) }
  }
  return err
}

func (p *TaggedToken) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetConfidenceList() {
    if err := oprot.WriteFieldBegin("confidenceList", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:confidenceList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.DOUBLE, len(p.ConfidenceList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ConfidenceList {
      if err := oprot.WriteDouble(float64(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:confidenceList: ", p), err) }
  }
  return err
}

func (p *TaggedToken) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TaggedToken(%+v)", *p)
}

// A theory about some token-level annotation.
// The TokenTagging consists of a mapping from tokens
// (using token ids) to string tags (e.g. part-of-speech tags or lemmas).
// 
// The mapping defined by a TokenTagging may be partial --
// i.e., some tokens may not be assigned any part of speech tags.
// 
// For lattice tokenizations, you may need to create multiple
// part-of-speech taggings (for different paths through the lattice),
// since the appropriate tag for a given token may depend on the path
// taken. For example, you might define a separate
// TokenTagging for each of the top K paths, which leaves all
// tokens that are not part of the path unlabeled.
// 
// Currently, we use strings to encode annotations. In
// the future, we may add fields for encoding specific tag sets
// (eg treebank tags), or for adding compound tags.
// 
// Attributes:
//  - UUID: The UUID of this TokenTagging object.
//  - Metadata: Information about where the annotation came from.
// This should be used to tell between gold-standard annotations
// and automatically generated theories about the data
//  - TaggedTokenList: The mapping from tokens to annotations.
// This may be a partial mapping.
//  - TaggingType: An ontology-backed string that represents the
// type of token taggings this TokenTagging object
// produces.
type TokenTagging struct {
  UUID *UUID `thrift:"uuid,1,required" db:"uuid" json:"uuid"`
  Metadata *AnnotationMetadata `thrift:"metadata,2,required" db:"metadata" json:"metadata"`
  TaggedTokenList []*TaggedToken `thrift:"taggedTokenList,3,required" db:"taggedTokenList" json:"taggedTokenList"`
  TaggingType *string `thrift:"taggingType,4" db:"taggingType" json:"taggingType,omitempty"`
}

func NewTokenTagging() *TokenTagging {
  return &TokenTagging{}
}

var TokenTagging_UUID_DEFAULT *UUID
func (p *TokenTagging) GetUUID() *UUID {
  if !p.IsSetUUID() {
    return TokenTagging_UUID_DEFAULT
  }
return p.UUID
}
var TokenTagging_Metadata_DEFAULT *AnnotationMetadata
func (p *TokenTagging) GetMetadata() *AnnotationMetadata {
  if !p.IsSetMetadata() {
    return TokenTagging_Metadata_DEFAULT
  }
return p.Metadata
}

func (p *TokenTagging) GetTaggedTokenList() []*TaggedToken {
  return p.TaggedTokenList
}
var TokenTagging_TaggingType_DEFAULT string
func (p *TokenTagging) GetTaggingType() string {
  if !p.IsSetTaggingType() {
    return TokenTagging_TaggingType_DEFAULT
  }
return *p.TaggingType
}
func (p *TokenTagging) IsSetUUID() bool {
  return p.UUID != nil
}

func (p *TokenTagging) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *TokenTagging) IsSetTaggingType() bool {
  return p.TaggingType != nil
}

func (p *TokenTagging) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUUID bool = false;
  var issetMetadata bool = false;
  var issetTaggedTokenList bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetUUID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetMetadata = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetTaggedTokenList = true
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UUID is not set"));
  }
  if !issetMetadata{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Metadata is not set"));
  }
  if !issetTaggedTokenList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TaggedTokenList is not set"));
  }
  return nil
}

func (p *TokenTagging)  ReadField1(iprot thrift.TProtocol) error {
  p.UUID = &UUID{}
  if err := p.UUID.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UUID), err)
  }
  return nil
}

func (p *TokenTagging)  ReadField2(iprot thrift.TProtocol) error {
  p.Metadata = &AnnotationMetadata{
  KBest: 1,
}
  if err := p.Metadata.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Metadata), err)
  }
  return nil
}

func (p *TokenTagging)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TaggedToken, 0, size)
  p.TaggedTokenList =  tSlice
  for i := 0; i < size; i ++ {
    _elem7 := &TaggedToken{}
    if err := _elem7.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem7), err)
    }
    p.TaggedTokenList = append(p.TaggedTokenList, _elem7)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenTagging)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TaggingType = &v
}
  return nil
}

func (p *TokenTagging) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TokenTagging"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TokenTagging) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("uuid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := p.UUID.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UUID), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *TokenTagging) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("metadata", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:metadata: ", p), err) }
  if err := p.Metadata.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Metadata), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:metadata: ", p), err) }
  return err
}

func (p *TokenTagging) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("taggedTokenList", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:taggedTokenList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.TaggedTokenList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.TaggedTokenList {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:taggedTokenList: ", p), err) }
  return err
}

func (p *TokenTagging) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetTaggingType() {
    if err := oprot.WriteFieldBegin("taggingType", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:taggingType: ", p), err) }
    if err := oprot.WriteString(string(*p.TaggingType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.taggingType (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:taggingType: ", p), err) }
  }
  return err
}

func (p *TokenTagging) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TokenTagging(%+v)", *p)
}

// Attributes:
//  - Weight
//  - TokenList
type LatticePath struct {
  Weight *float64 `thrift:"weight,1" db:"weight" json:"weight,omitempty"`
  TokenList []*Token `thrift:"tokenList,2,required" db:"tokenList" json:"tokenList"`
}

func NewLatticePath() *LatticePath {
  return &LatticePath{}
}

var LatticePath_Weight_DEFAULT float64
func (p *LatticePath) GetWeight() float64 {
  if !p.IsSetWeight() {
    return LatticePath_Weight_DEFAULT
  }
return *p.Weight
}

func (p *LatticePath) GetTokenList() []*Token {
  return p.TokenList
}
func (p *LatticePath) IsSetWeight() bool {
  return p.Weight != nil
}

func (p *LatticePath) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTokenList bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetTokenList = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTokenList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TokenList is not set"));
  }
  return nil
}

func (p *LatticePath)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Weight = &v
}
  return nil
}

func (p *LatticePath)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Token, 0, size)
  p.TokenList =  tSlice
  for i := 0; i < size; i ++ {
    _elem8 := &Token{}
    if err := _elem8.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem8), err)
    }
    p.TokenList = append(p.TokenList, _elem8)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *LatticePath) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("LatticePath"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LatticePath) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetWeight() {
    if err := oprot.WriteFieldBegin("weight", thrift.DOUBLE, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:weight: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.Weight)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.weight (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:weight: ", p), err) }
  }
  return err
}

func (p *LatticePath) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tokenList", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tokenList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.TokenList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.TokenList {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tokenList: ", p), err) }
  return err
}

func (p *LatticePath) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LatticePath(%+v)", *p)
}

// Type for arcs. For epsilon edges, leave 'token' blank.
// 
// Attributes:
//  - Src
//  - Dst
//  - Token
//  - Weight
type Arc struct {
  Src *int32 `thrift:"src,1" db:"src" json:"src,omitempty"`
  Dst *int32 `thrift:"dst,2" db:"dst" json:"dst,omitempty"`
  Token *Token `thrift:"token,3" db:"token" json:"token,omitempty"`
  Weight *float64 `thrift:"weight,4" db:"weight" json:"weight,omitempty"`
}

func NewArc() *Arc {
  return &Arc{}
}

var Arc_Src_DEFAULT int32
func (p *Arc) GetSrc() int32 {
  if !p.IsSetSrc() {
    return Arc_Src_DEFAULT
  }
return *p.Src
}
var Arc_Dst_DEFAULT int32
func (p *Arc) GetDst() int32 {
  if !p.IsSetDst() {
    return Arc_Dst_DEFAULT
  }
return *p.Dst
}
var Arc_Token_DEFAULT *Token
func (p *Arc) GetToken() *Token {
  if !p.IsSetToken() {
    return Arc_Token_DEFAULT
  }
return p.Token
}
var Arc_Weight_DEFAULT float64
func (p *Arc) GetWeight() float64 {
  if !p.IsSetWeight() {
    return Arc_Weight_DEFAULT
  }
return *p.Weight
}
func (p *Arc) IsSetSrc() bool {
  return p.Src != nil
}

func (p *Arc) IsSetDst() bool {
  return p.Dst != nil
}

func (p *Arc) IsSetToken() bool {
  return p.Token != nil
}

func (p *Arc) IsSetWeight() bool {
  return p.Weight != nil
}

func (p *Arc) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Arc)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Src = &v
}
  return nil
}

func (p *Arc)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Dst = &v
}
  return nil
}

func (p *Arc)  ReadField3(iprot thrift.TProtocol) error {
  p.Token = &Token{}
  if err := p.Token.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Token), err)
  }
  return nil
}

func (p *Arc)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Weight = &v
}
  return nil
}

func (p *Arc) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Arc"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Arc) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetSrc() {
    if err := oprot.WriteFieldBegin("src", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
    if err := oprot.WriteI32(int32(*p.Src)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.src (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  }
  return err
}

func (p *Arc) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetDst() {
    if err := oprot.WriteFieldBegin("dst", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:dst: ", p), err) }
    if err := oprot.WriteI32(int32(*p.Dst)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.dst (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:dst: ", p), err) }
  }
  return err
}

func (p *Arc) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetToken() {
    if err := oprot.WriteFieldBegin("token", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:token: ", p), err) }
    if err := p.Token.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Token), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:token: ", p), err) }
  }
  return err
}

func (p *Arc) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetWeight() {
    if err := oprot.WriteFieldBegin("weight", thrift.DOUBLE, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:weight: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.Weight)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.weight (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:weight: ", p), err) }
  }
  return err
}

func (p *Arc) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Arc(%+v)", *p)
}

// A lattice structure that assigns scores to a set of token
// sequences.  The lattice is encoded as an FSA, where states are
// identified by integers, and each arc is annotated with an
// optional tokens and a weight.  (Arcs with no tokens are
// "epsilon" arcs.)  The lattice has a single start state and a
// single end state.  (You can use epsilon edges to simulate
// multiple start states or multiple end states, if desired.)
// 
// The score of a path through the lattice is the sum of the weights
// of the arcs that make up that path.  A path with a lower score
// is considered "better" than a path with a higher score.
// 
// If possible, path scores should be negative log likelihoods
// (with base e -- e.g. if P=1, then weight=0; and if P=0.5, then
// weight=0.693).  Furthermore, if possible, the path scores should
// be globally normalized (i.e., they should encode probabilities).
// This will allow for them to be combined with other information
// in a reasonable way when determining confidences for system
// outputs.
// 
// TokenLattices should never contain any paths with cycles.  Every
// arc in the lattice should be included in some path from the start
// state to the end state.
// 
// Attributes:
//  - StartState
//  - EndState
//  - ArcList
//  - CachedBestPath
type TokenLattice struct {
  StartState int32 `thrift:"startState,1" db:"startState" json:"startState,omitempty"`
  EndState int32 `thrift:"endState,2" db:"endState" json:"endState,omitempty"`
  ArcList []*Arc `thrift:"arcList,3,required" db:"arcList" json:"arcList"`
  CachedBestPath *LatticePath `thrift:"cachedBestPath,4" db:"cachedBestPath" json:"cachedBestPath,omitempty"`
}

func NewTokenLattice() *TokenLattice {
  return &TokenLattice{}
}

var TokenLattice_StartState_DEFAULT int32 = 0

func (p *TokenLattice) GetStartState() int32 {
  return p.StartState
}
var TokenLattice_EndState_DEFAULT int32 = 0

func (p *TokenLattice) GetEndState() int32 {
  return p.EndState
}

func (p *TokenLattice) GetArcList() []*Arc {
  return p.ArcList
}
var TokenLattice_CachedBestPath_DEFAULT *LatticePath
func (p *TokenLattice) GetCachedBestPath() *LatticePath {
  if !p.IsSetCachedBestPath() {
    return TokenLattice_CachedBestPath_DEFAULT
  }
return p.CachedBestPath
}
func (p *TokenLattice) IsSetStartState() bool {
  return p.StartState != TokenLattice_StartState_DEFAULT
}

func (p *TokenLattice) IsSetEndState() bool {
  return p.EndState != TokenLattice_EndState_DEFAULT
}

func (p *TokenLattice) IsSetCachedBestPath() bool {
  return p.CachedBestPath != nil
}

func (p *TokenLattice) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetArcList bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetArcList = true
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetArcList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ArcList is not set"));
  }
  return nil
}

func (p *TokenLattice)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartState = v
}
  return nil
}

func (p *TokenLattice)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EndState = v
}
  return nil
}

func (p *TokenLattice)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Arc, 0, size)
  p.ArcList =  tSlice
  for i := 0; i < size; i ++ {
    _elem9 := &Arc{}
    if err := _elem9.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem9), err)
    }
    p.ArcList = append(p.ArcList, _elem9)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenLattice)  ReadField4(iprot thrift.TProtocol) error {
  p.CachedBestPath = &LatticePath{}
  if err := p.CachedBestPath.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CachedBestPath), err)
  }
  return nil
}

func (p *TokenLattice) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TokenLattice"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TokenLattice) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetStartState() {
    if err := oprot.WriteFieldBegin("startState", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:startState: ", p), err) }
    if err := oprot.WriteI32(int32(p.StartState)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.startState (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:startState: ", p), err) }
  }
  return err
}

func (p *TokenLattice) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetEndState() {
    if err := oprot.WriteFieldBegin("endState", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:endState: ", p), err) }
    if err := oprot.WriteI32(int32(p.EndState)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.endState (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:endState: ", p), err) }
  }
  return err
}

func (p *TokenLattice) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("arcList", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:arcList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ArcList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ArcList {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:arcList: ", p), err) }
  return err
}

func (p *TokenLattice) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetCachedBestPath() {
    if err := oprot.WriteFieldBegin("cachedBestPath", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:cachedBestPath: ", p), err) }
    if err := p.CachedBestPath.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CachedBestPath), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:cachedBestPath: ", p), err) }
  }
  return err
}

func (p *TokenLattice) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TokenLattice(%+v)", *p)
}

// A wrapper around a list of tokens.
// 
// Attributes:
//  - TokenList
type TokenList struct {
  TokenList []*Token `thrift:"tokenList,1,required" db:"tokenList" json:"tokenList"`
}

func NewTokenList() *TokenList {
  return &TokenList{}
}


func (p *TokenList) GetTokenList() []*Token {
  return p.TokenList
}
func (p *TokenList) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTokenList bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetTokenList = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTokenList{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TokenList is not set"));
  }
  return nil
}

func (p *TokenList)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Token, 0, size)
  p.TokenList =  tSlice
  for i := 0; i < size; i ++ {
    _elem10 := &Token{}
    if err := _elem10.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem10), err)
    }
    p.TokenList = append(p.TokenList, _elem10)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenList) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TokenList"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TokenList) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tokenList", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tokenList: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.TokenList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.TokenList {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tokenList: ", p), err) }
  return err
}

func (p *TokenList) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TokenList(%+v)", *p)
}

// A collection of tokens that represent a link to another resource.
// This resource might be another Concrete object (e.g., another
// Concrete Communication), represented with the 'concreteTarget'
// field, or it could link to a resource outside of Concrete via the
// 'externalTarget' field.
// 
// Attributes:
//  - Tokens: The tokens that make up this SpanLink object.
//  - ConcreteTarget
//  - ExternalTarget
//  - LinkType
type SpanLink struct {
  Tokens *TokenRefSequence `thrift:"tokens,1,required" db:"tokens" json:"tokens"`
  ConcreteTarget *UUID `thrift:"concreteTarget,2" db:"concreteTarget" json:"concreteTarget,omitempty"`
  ExternalTarget *string `thrift:"externalTarget,3" db:"externalTarget" json:"externalTarget,omitempty"`
  LinkType string `thrift:"linkType,4,required" db:"linkType" json:"linkType"`
}

func NewSpanLink() *SpanLink {
  return &SpanLink{}
}

var SpanLink_Tokens_DEFAULT *TokenRefSequence
func (p *SpanLink) GetTokens() *TokenRefSequence {
  if !p.IsSetTokens() {
    return SpanLink_Tokens_DEFAULT
  }
return p.Tokens
}
var SpanLink_ConcreteTarget_DEFAULT *UUID
func (p *SpanLink) GetConcreteTarget() *UUID {
  if !p.IsSetConcreteTarget() {
    return SpanLink_ConcreteTarget_DEFAULT
  }
return p.ConcreteTarget
}
var SpanLink_ExternalTarget_DEFAULT string
func (p *SpanLink) GetExternalTarget() string {
  if !p.IsSetExternalTarget() {
    return SpanLink_ExternalTarget_DEFAULT
  }
return *p.ExternalTarget
}

func (p *SpanLink) GetLinkType() string {
  return p.LinkType
}
func (p *SpanLink) IsSetTokens() bool {
  return p.Tokens != nil
}

func (p *SpanLink) IsSetConcreteTarget() bool {
  return p.ConcreteTarget != nil
}

func (p *SpanLink) IsSetExternalTarget() bool {
  return p.ExternalTarget != nil
}

func (p *SpanLink) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTokens bool = false;
  var issetLinkType bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetTokens = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
      issetLinkType = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTokens{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tokens is not set"));
  }
  if !issetLinkType{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field LinkType is not set"));
  }
  return nil
}

func (p *SpanLink)  ReadField1(iprot thrift.TProtocol) error {
  p.Tokens = &TokenRefSequence{
  AnchorTokenIndex: -1,
}
  if err := p.Tokens.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tokens), err)
  }
  return nil
}

func (p *SpanLink)  ReadField2(iprot thrift.TProtocol) error {
  p.ConcreteTarget = &UUID{}
  if err := p.ConcreteTarget.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ConcreteTarget), err)
  }
  return nil
}

func (p *SpanLink)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ExternalTarget = &v
}
  return nil
}

func (p *SpanLink)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.LinkType = v
}
  return nil
}

func (p *SpanLink) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("SpanLink"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpanLink) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tokens", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tokens: ", p), err) }
  if err := p.Tokens.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tokens), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tokens: ", p), err) }
  return err
}

func (p *SpanLink) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetConcreteTarget() {
    if err := oprot.WriteFieldBegin("concreteTarget", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:concreteTarget: ", p), err) }
    if err := p.ConcreteTarget.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ConcreteTarget), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:concreteTarget: ", p), err) }
  }
  return err
}

func (p *SpanLink) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetExternalTarget() {
    if err := oprot.WriteFieldBegin("externalTarget", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:externalTarget: ", p), err) }
    if err := oprot.WriteString(string(*p.ExternalTarget)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.externalTarget (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:externalTarget: ", p), err) }
  }
  return err
}

func (p *SpanLink) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("linkType", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:linkType: ", p), err) }
  if err := oprot.WriteString(string(p.LinkType)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.linkType (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:linkType: ", p), err) }
  return err
}

func (p *SpanLink) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpanLink(%+v)", *p)
}

// A theory (or set of alternative theories) about the sequence of
// tokens that make up a sentence.
// 
// This message type is used to record the output of not just for
// tokenizers, but also for a wide variety of other tools, including
// machine translation systems, text normalizers, part-of-speech
// taggers, and stemmers.
// 
// Each Tokenization is encoded using either a TokenList
// or a TokenLattice. (If you want to encode an n-best list, then
// you should store it as n separate Tokenization objects.) The
// "kind" field is used to indicate whether this Tokenization contains
// a list of tokens or a TokenLattice.
// 
// The confidence value for each sequence is determined by combining
// the confidence from the "metadata" field with confidence
// information from individual token sequences as follows:
// 
// <ul>
// <li> For n-best lists:
// metadata.confidence </li>
// <li> For lattices:
// metadata.confidence * exp(-sum(arc.weight)) </li>
// </ul>
// 
// Note: in some cases (such as the output of a machine translation
// tool), the order of the tokens in a token sequence may not
// correspond with the order of their original text span offsets.
// 
// Attributes:
//  - UUID
//  - Metadata: Information about where this tokenization came from.
//  - TokenList: A wrapper around an ordered list of the tokens in this tokenization.
// This may also give easy access to the "reconstructed text" associated
// with this tokenization.
// This field should only have a value if kind==TOKEN_LIST.
//  - Lattice: A lattice that compactly describes a set of token sequences that
// might make up this tokenization.  This field should only have a
// value if kind==LATTICE.
//  - Kind: Enumerated value indicating whether this tokenization is
// implemented using an n-best list or a lattice.
//  - TokenTaggingList
//  - ParseList
//  - DependencyParseList
//  - SpanLinkList
type Tokenization struct {
  UUID *UUID `thrift:"uuid,1,required" db:"uuid" json:"uuid"`
  Metadata *AnnotationMetadata `thrift:"metadata,2,required" db:"metadata" json:"metadata"`
  TokenList *TokenList `thrift:"tokenList,3" db:"tokenList" json:"tokenList,omitempty"`
  Lattice *TokenLattice `thrift:"lattice,4" db:"lattice" json:"lattice,omitempty"`
  Kind TokenizationKind `thrift:"kind,5,required" db:"kind" json:"kind"`
  TokenTaggingList []*TokenTagging `thrift:"tokenTaggingList,6" db:"tokenTaggingList" json:"tokenTaggingList,omitempty"`
  ParseList []*Parse `thrift:"parseList,7" db:"parseList" json:"parseList,omitempty"`
  DependencyParseList []*DependencyParse `thrift:"dependencyParseList,8" db:"dependencyParseList" json:"dependencyParseList,omitempty"`
  SpanLinkList []*SpanLink `thrift:"spanLinkList,9" db:"spanLinkList" json:"spanLinkList,omitempty"`
}

func NewTokenization() *Tokenization {
  return &Tokenization{}
}

var Tokenization_UUID_DEFAULT *UUID
func (p *Tokenization) GetUUID() *UUID {
  if !p.IsSetUUID() {
    return Tokenization_UUID_DEFAULT
  }
return p.UUID
}
var Tokenization_Metadata_DEFAULT *AnnotationMetadata
func (p *Tokenization) GetMetadata() *AnnotationMetadata {
  if !p.IsSetMetadata() {
    return Tokenization_Metadata_DEFAULT
  }
return p.Metadata
}
var Tokenization_TokenList_DEFAULT *TokenList
func (p *Tokenization) GetTokenList() *TokenList {
  if !p.IsSetTokenList() {
    return Tokenization_TokenList_DEFAULT
  }
return p.TokenList
}
var Tokenization_Lattice_DEFAULT *TokenLattice
func (p *Tokenization) GetLattice() *TokenLattice {
  if !p.IsSetLattice() {
    return Tokenization_Lattice_DEFAULT
  }
return p.Lattice
}

func (p *Tokenization) GetKind() TokenizationKind {
  return p.Kind
}
var Tokenization_TokenTaggingList_DEFAULT []*TokenTagging

func (p *Tokenization) GetTokenTaggingList() []*TokenTagging {
  return p.TokenTaggingList
}
var Tokenization_ParseList_DEFAULT []*Parse

func (p *Tokenization) GetParseList() []*Parse {
  return p.ParseList
}
var Tokenization_DependencyParseList_DEFAULT []*DependencyParse

func (p *Tokenization) GetDependencyParseList() []*DependencyParse {
  return p.DependencyParseList
}
var Tokenization_SpanLinkList_DEFAULT []*SpanLink

func (p *Tokenization) GetSpanLinkList() []*SpanLink {
  return p.SpanLinkList
}
func (p *Tokenization) IsSetUUID() bool {
  return p.UUID != nil
}

func (p *Tokenization) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *Tokenization) IsSetTokenList() bool {
  return p.TokenList != nil
}

func (p *Tokenization) IsSetLattice() bool {
  return p.Lattice != nil
}

func (p *Tokenization) IsSetTokenTaggingList() bool {
  return p.TokenTaggingList != nil
}

func (p *Tokenization) IsSetParseList() bool {
  return p.ParseList != nil
}

func (p *Tokenization) IsSetDependencyParseList() bool {
  return p.DependencyParseList != nil
}

func (p *Tokenization) IsSetSpanLinkList() bool {
  return p.SpanLinkList != nil
}

func (p *Tokenization) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUUID bool = false;
  var issetMetadata bool = false;
  var issetKind bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetUUID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetMetadata = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
      issetKind = true
    case 6:
      if err := p.ReadField6(iprot); err != nil {
        return err
      }
    case 7:
      if err := p.ReadField7(iprot); err != nil {
        return err
      }
    case 8:
      if err := p.ReadField8(iprot); err != nil {
        return err
      }
    case 9:
      if err := p.ReadField9(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UUID is not set"));
  }
  if !issetMetadata{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Metadata is not set"));
  }
  if !issetKind{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Kind is not set"));
  }
  return nil
}

func (p *Tokenization)  ReadField1(iprot thrift.TProtocol) error {
  p.UUID = &UUID{}
  if err := p.UUID.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UUID), err)
  }
  return nil
}

func (p *Tokenization)  ReadField2(iprot thrift.TProtocol) error {
  p.Metadata = &AnnotationMetadata{
  KBest: 1,
}
  if err := p.Metadata.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Metadata), err)
  }
  return nil
}

func (p *Tokenization)  ReadField3(iprot thrift.TProtocol) error {
  p.TokenList = &TokenList{}
  if err := p.TokenList.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TokenList), err)
  }
  return nil
}

func (p *Tokenization)  ReadField4(iprot thrift.TProtocol) error {
  p.Lattice = &TokenLattice{}
  if err := p.Lattice.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Lattice), err)
  }
  return nil
}

func (p *Tokenization)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := TokenizationKind(v)
  p.Kind = temp
}
  return nil
}

func (p *Tokenization)  ReadField6(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TokenTagging, 0, size)
  p.TokenTaggingList =  tSlice
  for i := 0; i < size; i ++ {
    _elem11 := &TokenTagging{}
    if err := _elem11.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem11), err)
    }
    p.TokenTaggingList = append(p.TokenTaggingList, _elem11)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Tokenization)  ReadField7(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Parse, 0, size)
  p.ParseList =  tSlice
  for i := 0; i < size; i ++ {
    _elem12 := &Parse{}
    if err := _elem12.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem12), err)
    }
    p.ParseList = append(p.ParseList, _elem12)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Tokenization)  ReadField8(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*DependencyParse, 0, size)
  p.DependencyParseList =  tSlice
  for i := 0; i < size; i ++ {
    _elem13 := &DependencyParse{}
    if err := _elem13.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem13), err)
    }
    p.DependencyParseList = append(p.DependencyParseList, _elem13)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Tokenization)  ReadField9(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpanLink, 0, size)
  p.SpanLinkList =  tSlice
  for i := 0; i < size; i ++ {
    _elem14 := &SpanLink{}
    if err := _elem14.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem14), err)
    }
    p.SpanLinkList = append(p.SpanLinkList, _elem14)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Tokenization) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Tokenization"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
    if err := p.writeField7(oprot); err != nil { return err }
    if err := p.writeField8(oprot); err != nil { return err }
    if err := p.writeField9(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Tokenization) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("uuid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := p.UUID.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UUID), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *Tokenization) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("metadata", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:metadata: ", p), err) }
  if err := p.Metadata.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Metadata), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:metadata: ", p), err) }
  return err
}

func (p *Tokenization) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTokenList() {
    if err := oprot.WriteFieldBegin("tokenList", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:tokenList: ", p), err) }
    if err := p.TokenList.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TokenList), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:tokenList: ", p), err) }
  }
  return err
}

func (p *Tokenization) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetLattice() {
    if err := oprot.WriteFieldBegin("lattice", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:lattice: ", p), err) }
    if err := p.Lattice.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Lattice), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:lattice: ", p), err) }
  }
  return err
}

func (p *Tokenization) writeField5(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("kind", thrift.I32, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:kind: ", p), err) }
  if err := oprot.WriteI32(int32(p.Kind)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.kind (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:kind: ", p), err) }
  return err
}

func (p *Tokenization) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetTokenTaggingList() {
    if err := oprot.WriteFieldBegin("tokenTaggingList", thrift.LIST, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tokenTaggingList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.TokenTaggingList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.TokenTaggingList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tokenTaggingList: ", p), err) }
  }
  return err
}

func (p *Tokenization) writeField7(oprot thrift.TProtocol) (err error) {
  if p.IsSetParseList() {
    if err := oprot.WriteFieldBegin("parseList", thrift.LIST, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:parseList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ParseList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ParseList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:parseList: ", p), err) }
  }
  return err
}

func (p *Tokenization) writeField8(oprot thrift.TProtocol) (err error) {
  if p.IsSetDependencyParseList() {
    if err := oprot.WriteFieldBegin("dependencyParseList", thrift.LIST, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:dependencyParseList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.DependencyParseList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.DependencyParseList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:dependencyParseList: ", p), err) }
  }
  return err
}

func (p *Tokenization) writeField9(oprot thrift.TProtocol) (err error) {
  if p.IsSetSpanLinkList() {
    if err := oprot.WriteFieldBegin("spanLinkList", thrift.LIST, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:spanLinkList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.SpanLinkList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.SpanLinkList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:spanLinkList: ", p), err) }
  }
  return err
}

func (p *Tokenization) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Tokenization(%+v)", *p)
}

// A single sentence or utterance in a communication.
// 
// Attributes:
//  - UUID
//  - Tokenization: Theory about the tokens that make up this sentence.  For text
// communications, these tokenizations will typically be generated
// by a tokenizer.  For audio communications, these tokenizations
// will typically be generated by an automatic speech recognizer.
// 
// The "Tokenization" message type is also used to store the output
// of machine translation systems and text normalization
// systems.
//  - TextSpan: Location of this sentence in the communication text.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
//  - RawTextSpan: Location of this sentence in the raw text.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
//  - AudioSpan: Location of this sentence in the original audio.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
type Sentence struct {
  UUID *UUID `thrift:"uuid,1,required" db:"uuid" json:"uuid"`
  Tokenization *Tokenization `thrift:"tokenization,2" db:"tokenization" json:"tokenization,omitempty"`
  TextSpan *TextSpan `thrift:"textSpan,3" db:"textSpan" json:"textSpan,omitempty"`
  RawTextSpan *TextSpan `thrift:"rawTextSpan,4" db:"rawTextSpan" json:"rawTextSpan,omitempty"`
  AudioSpan *AudioSpan `thrift:"audioSpan,5" db:"audioSpan" json:"audioSpan,omitempty"`
}

func NewSentence() *Sentence {
  return &Sentence{}
}

var Sentence_UUID_DEFAULT *UUID
func (p *Sentence) GetUUID() *UUID {
  if !p.IsSetUUID() {
    return Sentence_UUID_DEFAULT
  }
return p.UUID
}
var Sentence_Tokenization_DEFAULT *Tokenization
func (p *Sentence) GetTokenization() *Tokenization {
  if !p.IsSetTokenization() {
    return Sentence_Tokenization_DEFAULT
  }
return p.Tokenization
}
var Sentence_TextSpan_DEFAULT *TextSpan
func (p *Sentence) GetTextSpan() *TextSpan {
  if !p.IsSetTextSpan() {
    return Sentence_TextSpan_DEFAULT
  }
return p.TextSpan
}
var Sentence_RawTextSpan_DEFAULT *TextSpan
func (p *Sentence) GetRawTextSpan() *TextSpan {
  if !p.IsSetRawTextSpan() {
    return Sentence_RawTextSpan_DEFAULT
  }
return p.RawTextSpan
}
var Sentence_AudioSpan_DEFAULT *AudioSpan
func (p *Sentence) GetAudioSpan() *AudioSpan {
  if !p.IsSetAudioSpan() {
    return Sentence_AudioSpan_DEFAULT
  }
return p.AudioSpan
}
func (p *Sentence) IsSetUUID() bool {
  return p.UUID != nil
}

func (p *Sentence) IsSetTokenization() bool {
  return p.Tokenization != nil
}

func (p *Sentence) IsSetTextSpan() bool {
  return p.TextSpan != nil
}

func (p *Sentence) IsSetRawTextSpan() bool {
  return p.RawTextSpan != nil
}

func (p *Sentence) IsSetAudioSpan() bool {
  return p.AudioSpan != nil
}

func (p *Sentence) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUUID bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetUUID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UUID is not set"));
  }
  return nil
}

func (p *Sentence)  ReadField1(iprot thrift.TProtocol) error {
  p.UUID = &UUID{}
  if err := p.UUID.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UUID), err)
  }
  return nil
}

func (p *Sentence)  ReadField2(iprot thrift.TProtocol) error {
  p.Tokenization = &Tokenization{}
  if err := p.Tokenization.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tokenization), err)
  }
  return nil
}

func (p *Sentence)  ReadField3(iprot thrift.TProtocol) error {
  p.TextSpan = &TextSpan{}
  if err := p.TextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TextSpan), err)
  }
  return nil
}

func (p *Sentence)  ReadField4(iprot thrift.TProtocol) error {
  p.RawTextSpan = &TextSpan{}
  if err := p.RawTextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RawTextSpan), err)
  }
  return nil
}

func (p *Sentence)  ReadField5(iprot thrift.TProtocol) error {
  p.AudioSpan = &AudioSpan{}
  if err := p.AudioSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AudioSpan), err)
  }
  return nil
}

func (p *Sentence) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Sentence"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Sentence) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("uuid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := p.UUID.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UUID), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *Sentence) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetTokenization() {
    if err := oprot.WriteFieldBegin("tokenization", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tokenization: ", p), err) }
    if err := p.Tokenization.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tokenization), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tokenization: ", p), err) }
  }
  return err
}

func (p *Sentence) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTextSpan() {
    if err := oprot.WriteFieldBegin("textSpan", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:textSpan: ", p), err) }
    if err := p.TextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:textSpan: ", p), err) }
  }
  return err
}

func (p *Sentence) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetRawTextSpan() {
    if err := oprot.WriteFieldBegin("rawTextSpan", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rawTextSpan: ", p), err) }
    if err := p.RawTextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RawTextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rawTextSpan: ", p), err) }
  }
  return err
}

func (p *Sentence) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetAudioSpan() {
    if err := oprot.WriteFieldBegin("audioSpan", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:audioSpan: ", p), err) }
    if err := p.AudioSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AudioSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:audioSpan: ", p), err) }
  }
  return err
}

func (p *Sentence) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Sentence(%+v)", *p)
}

// A single "section" of a communication, such as a paragraph. Each
// section is defined using a text or audio span, and can optionally
// contain a list of sentences.
// 
// Attributes:
//  - UUID: The unique identifier for this section.
//  - SentenceList: The sentences of this "section."
//  - TextSpan: Location of this section in the communication text.
// 
// NOTE: This text span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
//  - RawTextSpan: Location of this section in the raw text.
// 
// NOTE: This text span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
//  - AudioSpan: Location of this section in the original audio.
// 
// NOTE: This span represents a best guess, or 'provenance':
// it cannot be guaranteed that this text span matches the _exact_
// text of the original document, but is the annotation's best
// effort at such a representation.
//  - Kind: A short, sometimes corpus-specific term characterizing the nature
// of the section; may change in a future version of concrete.  This
// often acts as a coarse-grained descriptor that is used for
// filtering.  For example, Gigaword uses the section kind "passage"
// to distinguish content-bearing paragraphs in the body of an
// article from other paragraphs, such as the headline and dateline.
//  - Label: The name of the section. For example, a title of a section on
// Wikipedia.
//  - NumberList: Position within the communication with respect to other Sections:
// The section number, E.g., 3, or 3.1, or 3.1.2, etc. Aimed at
// Communications with content organized in a hierarchy, such as a Book
// with multiple chapters, then sections, then paragraphs. Or even a
// dense Wikipedia page with subsections. Sections should still be
// arranged linearly, where reading these numbers should not be required
// to get a start-to-finish enumeration of the Communication's content.
//  - LidList: An optional field to be used for multi-language documents.
// 
// This field should be populated when a section is inside of
// a document that contains multiple languages.
// 
// Minimally, each block of text in one language should be it's own
// section. For example, if a paragraph is in English and the
// paragraph afterwards is in French, these should be separated into
// two different sections, allowing language-specific analytics to
// run on appropriate sections.
type Section struct {
  UUID *UUID `thrift:"uuid,1,required" db:"uuid" json:"uuid"`
  SentenceList []*Sentence `thrift:"sentenceList,2" db:"sentenceList" json:"sentenceList,omitempty"`
  TextSpan *TextSpan `thrift:"textSpan,3" db:"textSpan" json:"textSpan,omitempty"`
  RawTextSpan *TextSpan `thrift:"rawTextSpan,4" db:"rawTextSpan" json:"rawTextSpan,omitempty"`
  Kind string `thrift:"kind,5,required" db:"kind" json:"kind"`
  Label *string `thrift:"label,6" db:"label" json:"label,omitempty"`
  NumberList []int32 `thrift:"numberList,7" db:"numberList" json:"numberList,omitempty"`
  LidList []*LanguageIdentification `thrift:"lidList,8" db:"lidList" json:"lidList,omitempty"`
  AudioSpan *AudioSpan `thrift:"audioSpan,9" db:"audioSpan" json:"audioSpan,omitempty"`
}

func NewSection() *Section {
  return &Section{}
}

var Section_UUID_DEFAULT *UUID
func (p *Section) GetUUID() *UUID {
  if !p.IsSetUUID() {
    return Section_UUID_DEFAULT
  }
return p.UUID
}
var Section_SentenceList_DEFAULT []*Sentence

func (p *Section) GetSentenceList() []*Sentence {
  return p.SentenceList
}
var Section_TextSpan_DEFAULT *TextSpan
func (p *Section) GetTextSpan() *TextSpan {
  if !p.IsSetTextSpan() {
    return Section_TextSpan_DEFAULT
  }
return p.TextSpan
}
var Section_RawTextSpan_DEFAULT *TextSpan
func (p *Section) GetRawTextSpan() *TextSpan {
  if !p.IsSetRawTextSpan() {
    return Section_RawTextSpan_DEFAULT
  }
return p.RawTextSpan
}
var Section_AudioSpan_DEFAULT *AudioSpan
func (p *Section) GetAudioSpan() *AudioSpan {
  if !p.IsSetAudioSpan() {
    return Section_AudioSpan_DEFAULT
  }
return p.AudioSpan
}

func (p *Section) GetKind() string {
  return p.Kind
}
var Section_Label_DEFAULT string
func (p *Section) GetLabel() string {
  if !p.IsSetLabel() {
    return Section_Label_DEFAULT
  }
return *p.Label
}
var Section_NumberList_DEFAULT []int32

func (p *Section) GetNumberList() []int32 {
  return p.NumberList
}
var Section_LidList_DEFAULT []*LanguageIdentification

func (p *Section) GetLidList() []*LanguageIdentification {
  return p.LidList
}
func (p *Section) IsSetUUID() bool {
  return p.UUID != nil
}

func (p *Section) IsSetSentenceList() bool {
  return p.SentenceList != nil
}

func (p *Section) IsSetTextSpan() bool {
  return p.TextSpan != nil
}

func (p *Section) IsSetRawTextSpan() bool {
  return p.RawTextSpan != nil
}

func (p *Section) IsSetAudioSpan() bool {
  return p.AudioSpan != nil
}

func (p *Section) IsSetLabel() bool {
  return p.Label != nil
}

func (p *Section) IsSetNumberList() bool {
  return p.NumberList != nil
}

func (p *Section) IsSetLidList() bool {
  return p.LidList != nil
}

func (p *Section) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUUID bool = false;
  var issetKind bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetUUID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 9:
      if err := p.ReadField9(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
      issetKind = true
    case 6:
      if err := p.ReadField6(iprot); err != nil {
        return err
      }
    case 7:
      if err := p.ReadField7(iprot); err != nil {
        return err
      }
    case 8:
      if err := p.ReadField8(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UUID is not set"));
  }
  if !issetKind{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Kind is not set"));
  }
  return nil
}

func (p *Section)  ReadField1(iprot thrift.TProtocol) error {
  p.UUID = &UUID{}
  if err := p.UUID.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UUID), err)
  }
  return nil
}

func (p *Section)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Sentence, 0, size)
  p.SentenceList =  tSlice
  for i := 0; i < size; i ++ {
    _elem15 := &Sentence{}
    if err := _elem15.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem15), err)
    }
    p.SentenceList = append(p.SentenceList, _elem15)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Section)  ReadField3(iprot thrift.TProtocol) error {
  p.TextSpan = &TextSpan{}
  if err := p.TextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TextSpan), err)
  }
  return nil
}

func (p *Section)  ReadField4(iprot thrift.TProtocol) error {
  p.RawTextSpan = &TextSpan{}
  if err := p.RawTextSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RawTextSpan), err)
  }
  return nil
}

func (p *Section)  ReadField9(iprot thrift.TProtocol) error {
  p.AudioSpan = &AudioSpan{}
  if err := p.AudioSpan.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AudioSpan), err)
  }
  return nil
}

func (p *Section)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Kind = v
}
  return nil
}

func (p *Section)  ReadField6(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Label = &v
}
  return nil
}

func (p *Section)  ReadField7(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.NumberList =  tSlice
  for i := 0; i < size; i ++ {
var _elem16 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem16 = v
}
    p.NumberList = append(p.NumberList, _elem16)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Section)  ReadField8(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*LanguageIdentification, 0, size)
  p.LidList =  tSlice
  for i := 0; i < size; i ++ {
    _elem17 := &LanguageIdentification{}
    if err := _elem17.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem17), err)
    }
    p.LidList = append(p.LidList, _elem17)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Section) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Section"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
    if err := p.writeField7(oprot); err != nil { return err }
    if err := p.writeField8(oprot); err != nil { return err }
    if err := p.writeField9(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Section) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("uuid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := p.UUID.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UUID), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *Section) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSentenceList() {
    if err := oprot.WriteFieldBegin("sentenceList", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sentenceList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.SentenceList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.SentenceList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sentenceList: ", p), err) }
  }
  return err
}

func (p *Section) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTextSpan() {
    if err := oprot.WriteFieldBegin("textSpan", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:textSpan: ", p), err) }
    if err := p.TextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:textSpan: ", p), err) }
  }
  return err
}

func (p *Section) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetRawTextSpan() {
    if err := oprot.WriteFieldBegin("rawTextSpan", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rawTextSpan: ", p), err) }
    if err := p.RawTextSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RawTextSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rawTextSpan: ", p), err) }
  }
  return err
}

func (p *Section) writeField5(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("kind", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:kind: ", p), err) }
  if err := oprot.WriteString(string(p.Kind)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.kind (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:kind: ", p), err) }
  return err
}

func (p *Section) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetLabel() {
    if err := oprot.WriteFieldBegin("label", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:label: ", p), err) }
    if err := oprot.WriteString(string(*p.Label)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.label (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:label: ", p), err) }
  }
  return err
}

func (p *Section) writeField7(oprot thrift.TProtocol) (err error) {
  if p.IsSetNumberList() {
    if err := oprot.WriteFieldBegin("numberList", thrift.LIST, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:numberList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(p.NumberList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.NumberList {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:numberList: ", p), err) }
  }
  return err
}

func (p *Section) writeField8(oprot thrift.TProtocol) (err error) {
  if p.IsSetLidList() {
    if err := oprot.WriteFieldBegin("lidList", thrift.LIST, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:lidList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.LidList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.LidList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:lidList: ", p), err) }
  }
  return err
}

func (p *Section) writeField9(oprot thrift.TProtocol) (err error) {
  if p.IsSetAudioSpan() {
    if err := oprot.WriteFieldBegin("audioSpan", thrift.STRUCT, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:audioSpan: ", p), err) }
    if err := p.AudioSpan.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AudioSpan), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:audioSpan: ", p), err) }
  }
  return err
}

func (p *Section) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Section(%+v)", *p)
}


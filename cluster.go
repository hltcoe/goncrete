// Autogenerated by Thrift Compiler (0.10.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package goncrete

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

// An item being clustered. Does not designate cluster _membership_, as in
// "item x belongs to cluster C", but rather just the item ("x" in this
// example). Membership is indicated through Cluster objects.  An item may be a
// Entity, EntityMention, Situation, SituationMention, or technically anything
// with a UUID.
// 
// Attributes:
//  - CommunicationId: UUID of the Communication which contains the item specified by 'elementId'.
// This is ancillary info assuming UUIDs are indeed universally unique.
//  - SetId: UUID of the Entity|Situation(Mention)Set which contains the item specified by 'elementId'.
// This is ancillary info assuming UUIDs are indeed universally unique.
//  - ElementId: UUID of the EntityMention, Entity, SituationMention, or Situation that
// this item represents. This is the characteristic field.
type ClusterMember struct {
  CommunicationId *UUID `thrift:"communicationId,1,required" db:"communicationId" json:"communicationId"`
  SetId *UUID `thrift:"setId,2,required" db:"setId" json:"setId"`
  ElementId *UUID `thrift:"elementId,3,required" db:"elementId" json:"elementId"`
}

func NewClusterMember() *ClusterMember {
  return &ClusterMember{}
}

var ClusterMember_CommunicationId_DEFAULT *UUID
func (p *ClusterMember) GetCommunicationId() *UUID {
  if !p.IsSetCommunicationId() {
    return ClusterMember_CommunicationId_DEFAULT
  }
return p.CommunicationId
}
var ClusterMember_SetId_DEFAULT *UUID
func (p *ClusterMember) GetSetId() *UUID {
  if !p.IsSetSetId() {
    return ClusterMember_SetId_DEFAULT
  }
return p.SetId
}
var ClusterMember_ElementId_DEFAULT *UUID
func (p *ClusterMember) GetElementId() *UUID {
  if !p.IsSetElementId() {
    return ClusterMember_ElementId_DEFAULT
  }
return p.ElementId
}
func (p *ClusterMember) IsSetCommunicationId() bool {
  return p.CommunicationId != nil
}

func (p *ClusterMember) IsSetSetId() bool {
  return p.SetId != nil
}

func (p *ClusterMember) IsSetElementId() bool {
  return p.ElementId != nil
}

func (p *ClusterMember) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCommunicationId bool = false;
  var issetSetId bool = false;
  var issetElementId bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetCommunicationId = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetSetId = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
      issetElementId = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCommunicationId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CommunicationId is not set"));
  }
  if !issetSetId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SetId is not set"));
  }
  if !issetElementId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ElementId is not set"));
  }
  return nil
}

func (p *ClusterMember)  ReadField1(iprot thrift.TProtocol) error {
  p.CommunicationId = &UUID{}
  if err := p.CommunicationId.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CommunicationId), err)
  }
  return nil
}

func (p *ClusterMember)  ReadField2(iprot thrift.TProtocol) error {
  p.SetId = &UUID{}
  if err := p.SetId.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SetId), err)
  }
  return nil
}

func (p *ClusterMember)  ReadField3(iprot thrift.TProtocol) error {
  p.ElementId = &UUID{}
  if err := p.ElementId.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ElementId), err)
  }
  return nil
}

func (p *ClusterMember) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("ClusterMember"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ClusterMember) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("communicationId", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:communicationId: ", p), err) }
  if err := p.CommunicationId.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CommunicationId), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:communicationId: ", p), err) }
  return err
}

func (p *ClusterMember) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("setId", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:setId: ", p), err) }
  if err := p.SetId.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SetId), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:setId: ", p), err) }
  return err
}

func (p *ClusterMember) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("elementId", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:elementId: ", p), err) }
  if err := p.ElementId.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ElementId), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:elementId: ", p), err) }
  return err
}

func (p *ClusterMember) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ClusterMember(%+v)", *p)
}

// A set of items which are alike in some way.  Has an implicit id which is the
// index of this Cluster in its parent Clustering's 'clusterList'.
// 
// Attributes:
//  - ClusterMemberIndexList: The items in this cluster.  Values are indices into the
// 'clusterMemberList' of the Clustering which contains this Cluster.
//  - ConfidenceList: Co-indexed with 'clusterMemberIndexList'. The i^{th} value represents the
// confidence that mention clusterMemberIndexList[i] belongs to this cluster.
//  - ChildIndexList: A set of clusters (implicit ids/indices) from which this cluster was
// created. This cluster should represent the union of all the items in all
// of the child clusters.  (For hierarchical clustering only).
type Cluster struct {
  ClusterMemberIndexList []int32 `thrift:"clusterMemberIndexList,1" db:"clusterMemberIndexList" json:"clusterMemberIndexList,omitempty"`
  ConfidenceList []float64 `thrift:"confidenceList,2" db:"confidenceList" json:"confidenceList,omitempty"`
  ChildIndexList []int32 `thrift:"childIndexList,3" db:"childIndexList" json:"childIndexList,omitempty"`
}

func NewCluster() *Cluster {
  return &Cluster{}
}

var Cluster_ClusterMemberIndexList_DEFAULT []int32

func (p *Cluster) GetClusterMemberIndexList() []int32 {
  return p.ClusterMemberIndexList
}
var Cluster_ConfidenceList_DEFAULT []float64

func (p *Cluster) GetConfidenceList() []float64 {
  return p.ConfidenceList
}
var Cluster_ChildIndexList_DEFAULT []int32

func (p *Cluster) GetChildIndexList() []int32 {
  return p.ChildIndexList
}
func (p *Cluster) IsSetClusterMemberIndexList() bool {
  return p.ClusterMemberIndexList != nil
}

func (p *Cluster) IsSetConfidenceList() bool {
  return p.ConfidenceList != nil
}

func (p *Cluster) IsSetChildIndexList() bool {
  return p.ChildIndexList != nil
}

func (p *Cluster) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Cluster)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.ClusterMemberIndexList =  tSlice
  for i := 0; i < size; i ++ {
var _elem0 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem0 = v
}
    p.ClusterMemberIndexList = append(p.ClusterMemberIndexList, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Cluster)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]float64, 0, size)
  p.ConfidenceList =  tSlice
  for i := 0; i < size; i ++ {
var _elem1 float64
    if v, err := iprot.ReadDouble(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem1 = v
}
    p.ConfidenceList = append(p.ConfidenceList, _elem1)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Cluster)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.ChildIndexList =  tSlice
  for i := 0; i < size; i ++ {
var _elem2 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem2 = v
}
    p.ChildIndexList = append(p.ChildIndexList, _elem2)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Cluster) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Cluster"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Cluster) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetClusterMemberIndexList() {
    if err := oprot.WriteFieldBegin("clusterMemberIndexList", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterMemberIndexList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(p.ClusterMemberIndexList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ClusterMemberIndexList {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterMemberIndexList: ", p), err) }
  }
  return err
}

func (p *Cluster) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetConfidenceList() {
    if err := oprot.WriteFieldBegin("confidenceList", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:confidenceList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.DOUBLE, len(p.ConfidenceList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ConfidenceList {
      if err := oprot.WriteDouble(float64(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:confidenceList: ", p), err) }
  }
  return err
}

func (p *Cluster) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetChildIndexList() {
    if err := oprot.WriteFieldBegin("childIndexList", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:childIndexList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(p.ChildIndexList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ChildIndexList {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:childIndexList: ", p), err) }
  }
  return err
}

func (p *Cluster) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Cluster(%+v)", *p)
}

// An (optionally) hierarchical clustering of items appearing across a set of
// Communications (intra-Communication clusterings are encoded by Entities and
// Situations).  An item may be a Entity, EntityMention, Situation,
// SituationMention, or technically anything with a UUID.
// 
// Attributes:
//  - UUID: UUID for this Clustering object.
//  - Metadata: Metadata for this Clustering object.
//  - ClusterMemberList: The set of items being clustered.
//  - ClusterList: Clusters of items. If this is a hierarchical clustering, this may contain
// clusters which are the set of smaller clusters.
// Clusters may not "overlap", meaning (for all clusters X,Y):
//   X \cap Y \neq \emptyset \implies X \subset Y \vee Y \subset X
//  - RootClusterIndexList: A set of disjoint clusters (indices in 'clusterList') which cover all
// items in 'clusterMemberList'. This list must be specified for hierarchical
// clusterings and should not be specified for flat clusterings.
type Clustering struct {
  UUID *UUID `thrift:"uuid,1,required" db:"uuid" json:"uuid"`
  Metadata *AnnotationMetadata `thrift:"metadata,2,required" db:"metadata" json:"metadata"`
  ClusterMemberList []*ClusterMember `thrift:"clusterMemberList,3" db:"clusterMemberList" json:"clusterMemberList,omitempty"`
  ClusterList []*Cluster `thrift:"clusterList,4" db:"clusterList" json:"clusterList,omitempty"`
  RootClusterIndexList []int32 `thrift:"rootClusterIndexList,5" db:"rootClusterIndexList" json:"rootClusterIndexList,omitempty"`
}

func NewClustering() *Clustering {
  return &Clustering{}
}

var Clustering_UUID_DEFAULT *UUID
func (p *Clustering) GetUUID() *UUID {
  if !p.IsSetUUID() {
    return Clustering_UUID_DEFAULT
  }
return p.UUID
}
var Clustering_Metadata_DEFAULT *AnnotationMetadata
func (p *Clustering) GetMetadata() *AnnotationMetadata {
  if !p.IsSetMetadata() {
    return Clustering_Metadata_DEFAULT
  }
return p.Metadata
}
var Clustering_ClusterMemberList_DEFAULT []*ClusterMember

func (p *Clustering) GetClusterMemberList() []*ClusterMember {
  return p.ClusterMemberList
}
var Clustering_ClusterList_DEFAULT []*Cluster

func (p *Clustering) GetClusterList() []*Cluster {
  return p.ClusterList
}
var Clustering_RootClusterIndexList_DEFAULT []int32

func (p *Clustering) GetRootClusterIndexList() []int32 {
  return p.RootClusterIndexList
}
func (p *Clustering) IsSetUUID() bool {
  return p.UUID != nil
}

func (p *Clustering) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *Clustering) IsSetClusterMemberList() bool {
  return p.ClusterMemberList != nil
}

func (p *Clustering) IsSetClusterList() bool {
  return p.ClusterList != nil
}

func (p *Clustering) IsSetRootClusterIndexList() bool {
  return p.RootClusterIndexList != nil
}

func (p *Clustering) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUUID bool = false;
  var issetMetadata bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
      issetUUID = true
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
      issetMetadata = true
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UUID is not set"));
  }
  if !issetMetadata{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Metadata is not set"));
  }
  return nil
}

func (p *Clustering)  ReadField1(iprot thrift.TProtocol) error {
  p.UUID = &UUID{}
  if err := p.UUID.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UUID), err)
  }
  return nil
}

func (p *Clustering)  ReadField2(iprot thrift.TProtocol) error {
  p.Metadata = &AnnotationMetadata{
  KBest: 1,
}
  if err := p.Metadata.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Metadata), err)
  }
  return nil
}

func (p *Clustering)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ClusterMember, 0, size)
  p.ClusterMemberList =  tSlice
  for i := 0; i < size; i ++ {
    _elem3 := &ClusterMember{}
    if err := _elem3.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem3), err)
    }
    p.ClusterMemberList = append(p.ClusterMemberList, _elem3)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Clustering)  ReadField4(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Cluster, 0, size)
  p.ClusterList =  tSlice
  for i := 0; i < size; i ++ {
    _elem4 := &Cluster{}
    if err := _elem4.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
    }
    p.ClusterList = append(p.ClusterList, _elem4)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Clustering)  ReadField5(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.RootClusterIndexList =  tSlice
  for i := 0; i < size; i ++ {
var _elem5 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem5 = v
}
    p.RootClusterIndexList = append(p.RootClusterIndexList, _elem5)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Clustering) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Clustering"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Clustering) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("uuid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:uuid: ", p), err) }
  if err := p.UUID.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UUID), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:uuid: ", p), err) }
  return err
}

func (p *Clustering) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("metadata", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:metadata: ", p), err) }
  if err := p.Metadata.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Metadata), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:metadata: ", p), err) }
  return err
}

func (p *Clustering) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetClusterMemberList() {
    if err := oprot.WriteFieldBegin("clusterMemberList", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:clusterMemberList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ClusterMemberList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ClusterMemberList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:clusterMemberList: ", p), err) }
  }
  return err
}

func (p *Clustering) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetClusterList() {
    if err := oprot.WriteFieldBegin("clusterList", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:clusterList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ClusterList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ClusterList {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:clusterList: ", p), err) }
  }
  return err
}

func (p *Clustering) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetRootClusterIndexList() {
    if err := oprot.WriteFieldBegin("rootClusterIndexList", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:rootClusterIndexList: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(p.RootClusterIndexList)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.RootClusterIndexList {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:rootClusterIndexList: ", p), err) }
  }
  return err
}

func (p *Clustering) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Clustering(%+v)", *p)
}

